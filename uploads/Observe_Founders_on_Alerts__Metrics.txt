 In most metrics products, you're dropped into a sea of often cryptically named metrics, with little knowledge of how to get the right metric for the situation you're in, or even how to get that metric drawn correctly. Alright, so typical situation. There's a problem with X. What metrics can I find that might tell me about X? You're scrolling through pages and pages of dashboards trying to find something as relevant. You don't find it now browsing through thousands and thousands of raw metrics of how much you're looking for. The metric naming is all over the place, tax rate consistent, it's a mess. The way you observe stores and processes metrics data takes advantage of the unique capabilities of snowflake and is radically different from existing systems. In observe, the way you find metrics is dramatically different. When you look at a resource, we can find and surface the right metrics about that thing without any need to search. So we're trying to flip this on its head. So instead of paging through all those metrics and dashboards, it just goes straight to a resource page and will show you any metrics that are relevant. We'll leave an auto-generate dashboards based on those metrics. This metrics experience is almost disturbingly simple compared to similar products where you weigh through thousands of pointless tags and metric names. Our perspective, I guess largely is that you don't even need those tags anyway. Alright, if you can just correlate datasets together, if you can follow these transitive relationships in the data, you can answer these super nuanced questions. One thing I'm particularly excited about is our solution to the cardinality problem. Cardinality is the number of unique combinations of metric names such as CPU utilization, memory utilization, etc. and tags, such as the application name, Kubernetes pod name, and so forth. Existing systems require users to carefully plan and watch the cardinality of their metrics data to find the right balance between cardinality, cost, and performance. Observe does a way with all of that. In observe, cardinality is largely irrelevant for cost and performance. Applications may emit as many metrics and unique tags as they please, with no need for users to play with tuning knobs such as indexes. This data can be retained and queried potentially forever at full fidelity and with high performance. So when we were thinking about what to do with our learning feature, we wanted to make sure that we did more than just like fire and forget a learning. So at first it was some server is on fire and then it was these servers are on fire and now we need to know what services run on those servers and what customers are using those services. Learning about things or resources completely changes not only the experience of configuring alerts and monitors, but also how to make use of them when they finally trigger. The alert you want to see as a business operator is a customer is not having a good time. Oh no, because we do both time and relations, we can deliver that. We put a lot of effort into making sure there was somewhere meaningful to go when you click on our alert generated by observe. So instead of looking at random log entries or metric chart or whatever, you quickly see a list of like which users to this impact, how often has it happened in the past, what other issues might these users be experiencing? If you have a roster of things you care about and those things relate to each other, you would be a fool not to use observe. You should use observe.